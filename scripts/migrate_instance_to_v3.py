#!/usr/bin/env python3
"""
AGET Instance Migration to v3.0

Performs structural preparation for migrating an AGET instance from v2.x to v3.0
5D Composition Architecture.

Usage:
    python3 migrate_instance_to_v3.py /path/to/agent [options]

Options:
    --archetype     Archetype (worker|advisor|developer|supervisor|operator|consultant|etc.)
    --specialization Agent's specialization within archetype
    --north-star    North star statement (purpose)
    --dry-run       Show what would be done without making changes
    --execute       Actually perform the migration

Reference:
    - L395: Instance v3.0 Migration Pattern
    - L400: Conceptual vs Structural Migration Understanding
    - L403: knowledge/ Directory Population Guidance Gap
    - L376: Legacy File Version Sync (supervisor)
    - G-1.9: Directory Discoverability (governance/, planning/, sessions/ READMEs)
    - CAP-MIG-014: Legacy File Handling
    - CAP-MIG-015: Behavioral Validation Requirement
    - SOP_instance_migration_v3.md
    - AGET_INSTANCE_SPEC v1.0.0

Author: private-aget-framework-AGET
Date: 2025-12-27
Updated: 2025-12-28 (G-1.9 directory discoverability)
"""

import argparse
import json
import os
import re
import shutil
import sys
from datetime import datetime
from pathlib import Path


# =============================================================================
# Constants
# =============================================================================

ARCHETYPES = [
    "worker", "advisor", "developer", "architect", "supervisor",
    "consultant", "spec-engineer", "executive", "analyst",
    "reviewer", "operator", "researcher"
]

ARCHETYPE_DIRS = {
    "operator": ["operations"],
    "supervisor": ["fleet"],
    "developer": ["products"],
    "consultant": ["clients"],
    "advisor": ["clients"],
    "analyst": ["reports"],
}

CORE_VISIBLE_DIRS = ["governance", "sessions", "planning", "knowledge"]

FIVE_D_DIRS = ["persona", "memory", "reasoning", "skills", "context"]

# Legacy files to detect and remove (CAP-MIG-014, L376)
LEGACY_FILES = [
    ".aget/collaboration/agent_manifest.yaml",  # Superseded by manifest.yaml
]


# =============================================================================
# Templates
# =============================================================================

def get_identity_template(name: str, north_star: str) -> dict:
    """Generate identity.json template."""
    return {
        "name": name,
        "north_star": north_star or f"Purpose of {name}",
        "created": datetime.now().strftime("%Y-%m-%d"),
        "version": "1.0.0"
    }


def get_archetype_yaml(archetype: str, specialization: str) -> str:
    """Generate persona/archetype.yaml content."""
    return f"""# D1: PERSONA - Archetype Configuration
# Generated by migrate_instance_to_v3.py

archetype: {archetype}
specialization: {specialization or archetype}
governance:
  intensity: balanced

base_template: template-{archetype}-aget
"""


def get_style_yaml() -> str:
    """Generate persona/style.yaml content."""
    return """# D1: PERSONA - Communication Style

communication:
  formality: professional
  verbosity: concise
  tone: collaborative

modes:
  default: collaborative
  planning: structured
  analysis: thorough
"""


def get_layer_config_yaml(ldoc_count: int) -> str:
    """Generate memory/layer_config.yaml content."""
    return f"""# D2: MEMORY - Layer Configuration
# Reference: AGET_MEMORY_SPEC v1.2.0

layers:
  operational:
    enabled: true
    description: "Session context, immediate task state"
  semantic:
    enabled: true
    description: "Domain knowledge (knowledge/ directory)"
  episodic:
    enabled: true
    description: "Session history (sessions/ directory)"
  procedural:
    enabled: true
    description: "Patterns and workflows (.aget/patterns/)"
  strategic:
    enabled: true
    description: "Long-term goals and plans (planning/)"
  meta:
    enabled: true
    description: "Self-knowledge and learnings (.aget/evolution/)"

ldoc_config:
  threshold: 50
  index_required: {str(ldoc_count > 50).lower()}
  current_count: {ldoc_count}
"""


def get_inheritance_yaml(managed_by: str) -> str:
    """Generate memory/inheritance.yaml content."""
    return f"""# D2: MEMORY - Inheritance Configuration

inheritance:
  source: {managed_by}
  inherited_patterns:
    - substantial_change_protocol
    - gate_discipline

  inherited_l_docs:
    foundation:
      - L143  # AGET definition
      - L99   # Worker primacy
    governance:
      - L42   # Gate boundaries
"""


def get_decision_authority_yaml() -> str:
    """Generate reasoning/decision_authority.yaml content."""
    return """# D3: REASONING - Decision Authority Matrix

autonomous:
  - l_doc_creation
  - documentation
  - session_notes

propose_validate:
  - strategic_documents
  - project_plans

escalate:
  - major_versions
  - breaking_changes
  - external_actions
"""


def get_planning_patterns_yaml() -> str:
    """Generate reasoning/planning_patterns.yaml content."""
    return """# D3: REASONING - Planning Patterns

patterns:
  substantial_change:
    protocol: STOP-PLAN-PRESENT-WAIT
    reference: L42

  project_planning:
    format: PROJECT_PLAN_*.md
    location: planning/
    gates: required

  session:
    wake_up: required
    wind_down: required
    handoff: per_session
"""


def get_capabilities_yaml(archetype: str) -> str:
    """Generate skills/capabilities.yaml content."""
    return f"""# D4: SKILLS - Capability Configuration

capabilities:
  core:
    - capability-session-protocols
    - capability-evolution-tracking
    - capability-governance-balanced

  archetype:
    - capability-{archetype}-base

inviolables:
  - data_classification_respect
  - principal_consent_required
"""


def get_relationships_yaml(managed_by: str, portfolio: str) -> str:
    """Generate context/relationships.yaml content."""
    return f"""# D5: CONTEXT - Relationship Configuration

managed_by: {managed_by}

portfolio: {portfolio or "main"}

peers: []

coordinates_with:
  - {managed_by}
"""


def get_scope_yaml() -> str:
    """Generate context/scope.yaml content."""
    return """# D5: CONTEXT - Scope Configuration

in_scope:
  - primary_domain_operations
  - session_management
  - knowledge_capture

out_of_scope:
  - external_actions_without_approval
  - cross_portfolio_operations

boundaries:
  data_classification: standard
"""


def get_knowledge_readme() -> str:
    """Generate knowledge/README.md content (L403 fix)."""
    return """# Domain Knowledge

This directory contains domain-specific beliefs and knowledge that are **NOT portable** to other agents (per L296 portability test).

## Portability Test (L296)

> **"Clone this agent to a different domain/company. Would this content still be useful?"**
> - **YES** → `.aget/evolution/` (framework beliefs, portable)
> - **NO** → `knowledge/` (domain beliefs, NOT portable)

## Taxonomy

| Location | Content Type | Portability | Example |
|----------|--------------|-------------|---------|
| `.aget/evolution/` | Framework beliefs | Portable | "Gate discipline prevents scope creep" |
| `knowledge/` | Domain beliefs | NOT portable | "This workspace uses 30-day archive cycles" |
| `sessions/` | Temporal facts | Session-specific | "2025-12-27: Migrated to v3.0" |
| `data/` | Entity facts | Observations | Measurements, objects |

## Content Types

| Prefix | Type | Description |
|--------|------|-------------|
| `FOUNDATIONAL_*` | Core Concepts | Domain fundamentals, definitions, principles |
| `STRATEGIC_*` | Strategy | Long-term positioning, frameworks, roadmaps |
| `INTELLIGENCE_*` | Analysis | Market research, competitive analysis, insights |
| `PROGRAM_*` | Programs | Multi-project initiatives, cross-cutting concerns |
| `REFERENCE_*` | Reference | Glossaries, lookup tables, standards |
| `_ARCHIVE_*` | Archived | Deprecated content (kept for historical reference) |

## Structure

For small knowledge bases (<10 files):
```
knowledge/
├── README.md           # This file
├── FOUNDATIONAL_*.md   # Core domain concepts
└── REFERENCE_*.md      # Lookup tables, standards
```

For mature knowledge bases (>20 files):
```
knowledge/
├── README.md
├── INDEX.md            # Cross-reference map
├── {domain}/           # Domain-specific subdirectory
│   ├── patterns/       # Workflow patterns
│   └── heuristics/     # Decision rules
├── thresholds/         # Environment-specific values
└── _archive/           # Deprecated content
```

## Capture Protocol

**When to capture domain knowledge:**
1. **Session end**: "What did I learn specific to THIS domain?"
2. **Discovery**: "This pattern only works HERE"
3. **Decision**: "This threshold is right for THIS environment"

**Format:**
- Patterns: Markdown (`.md`)
- Heuristics: YAML with decision rules (`.yaml`)
- Thresholds: YAML with numeric values (`.yaml`)

## Validation States

Content progresses through validation:
1. **Hypothesis**: Untested assumption
2. **Validated**: Tested 3+ times, works consistently
3. **Established**: Proven pattern (becomes "knowledge")

Mark validation status in each document's frontmatter:
```yaml
---
status: validated  # hypothesis | validated | established
validated_count: 5
last_validated: 2025-12-27
---
```

## Graduation Triggers

Content moves from `sessions/` → `knowledge/` when:
1. Referenced 3+ times across sessions
2. Explicitly marked for graduation by user
3. Represents stable, reusable domain knowledge

## Boundaries

**knowledge/ is for:**
- Enduring reference material
- Domain-specific knowledge (NOT portable)
- Curated insights that survive sessions

**knowledge/ is NOT for:**
- L-docs (belong in `.aget/evolution/`)
- PROJECT_PLANs (belong in `planning/`)
- Session notes (belong in `sessions/`)
- Charter/Mission/Scope (belong in `governance/`)
- Framework beliefs (belong in `.aget/evolution/`)

---

*This template is part of AGET v3.0.0*
*See: L296 (Portability Test), L399 (Content Semantics), L403 (Population Guidance)*
*Canonical guide: KNOWLEDGE_TAXONOMY_GUIDE.md*
"""


def get_governance_readme() -> str:
    """Generate governance/README.md content (G-1.9 discoverability)."""
    return """# Governance Directory

This directory contains governance artifacts that define agent boundaries and authority.

## Required Files (CAP-INST-002)

| File | Purpose |
|------|---------|
| `CHARTER.md` | What this agent IS and IS NOT |
| `MISSION.md` | Goals and key results |
| `SCOPE_BOUNDARIES.md` | Authority limits and escalation paths |

## Optional Files

| File | Purpose |
|------|---------|
| `NAMING_CONVENTIONS.md` | Agent-specific naming rules |
| `DECISION_MATRIX.md` | Authority delegation rules |
| `MEMORY_VISION.md` | Memory architecture principles |

## Guidance

### What Goes Here

- **Operational boundaries** — not technical specifications
- **Authority definitions** — what decisions this agent can make autonomously
- **Escalation rules** — when to defer to supervisor or principal

### Maintenance

- Update `CHARTER.md` when scope changes
- Review `MISSION.md` quarterly for KR relevance
- Update `SCOPE_BOUNDARIES.md` when authority model changes

### Anti-Patterns

| Anti-Pattern | Why Bad | Instead |
|--------------|---------|---------|
| Technical specs in CHARTER | Conflates governance with implementation | Put specs in `.aget/specs/` |
| Vague MISSION goals | Not measurable | Use SMART criteria |
| Missing escalation paths | Agent operates beyond authority | Define explicit boundaries |

## Cross-References

| Document | Relationship |
|----------|--------------|
| `.aget/identity.json` | North Star alignment |
| `CLAUDE.md` | Operational instructions |
| `AGENTS.md` | Public-facing identity |

---

*Template version: 1.0.0 (G-1.9 discoverability)*
*Created by: private-aget-framework-AGET*
"""


def get_planning_readme() -> str:
    """Generate planning/README.md content (G-1.9 discoverability)."""
    return """# Planning Directory

This directory contains PROJECT_PLANs and related planning artifacts.

## Contents

| Pattern | Purpose |
|---------|---------|
| `PROJECT_PLAN_*.md` | Active and historical project plans |
| `DECISION_POINT_*.md` | Captured decision points |
| `FLEET_MIGRATION_PLAN_*.md` | Fleet-wide migration plans |

## Governance (L186)

### When to Use PROJECT_PLAN

Use PROJECT_PLAN pattern for **substantial work**:
- Multi-step implementations
- Cross-agent coordination
- Work requiring go/no-go gates

**Not TodoWrite** — TodoWrite is for session-level task tracking, not governance artifacts.

### Gate Discipline (L42)

- Include go/no-go gates with decision points
- Stop at gate boundaries
- Wait for explicit GO before proceeding
- Document gate completion with evidence

## Guidance

### Naming Convention

```
PROJECT_PLAN_<topic>_v<version>.md
DECISION_POINT_<topic>.md
FLEET_MIGRATION_PLAN_v<version>.md
```

### Lifecycle

| State | Meaning |
|-------|---------|
| PROPOSED | Awaiting approval |
| ACTIVE | In execution |
| BLOCKED | Waiting on dependency |
| COMPLETE | All gates passed |
| ARCHIVED | Historical reference |

### Archival

- Archive completed plans with completion date suffix
- Reference learnings (L-docs) in post-completion notes
- Move to `archive/` subdirectory if desired

## Anti-Patterns

| Anti-Pattern | Why Bad | Instead |
|--------------|---------|---------|
| No gates | No decision points | Add go/no-go gates |
| Unbounded scope | Scope creep | Define explicit deliverables |
| Missing success criteria | Can't validate completion | Add measurable criteria |

## Cross-References

| Document | Relationship |
|----------|--------------|
| `.aget/evolution/L186_*.md` | PROJECT_PLAN pattern learning |
| `.aget/evolution/L42_*.md` | Gate discipline learning |
| `governance/MISSION.md` | Alignment with goals |

---

*Template version: 1.0.0 (G-1.9 discoverability)*
*Created by: private-aget-framework-AGET*
"""


def get_sessions_readme() -> str:
    """Generate sessions/README.md content (G-1.9 discoverability)."""
    return """# Sessions Directory

This directory contains session notes and handoff documentation.

## Contents

| Pattern | Purpose |
|---------|---------|
| `session_YYYY-MM-DD_*.md` | Session notes |
| `HANDOFF_*.md` | Inter-session continuity documents |

## Session Protocol

### Wake Up (Session Start)

1. Execute `python3 .aget/patterns/session/wake_up.py`
2. Review pending work from previous sessions
3. Create session note with date stamp

### Wind Down (Session End)

1. Execute `python3 .aget/patterns/session/wind_down.py`
2. Update session note with work completed
3. Create HANDOFF if work continues to next session

## Guidance

### Session Note Content

| Section | Content |
|---------|---------|
| Context | What session was about |
| Work Completed | What was accomplished |
| Decisions Made | Key decisions and rationale |
| Blocked Items | What couldn't be completed and why |
| Next Actions | What needs to happen next |

### HANDOFF Content

| Section | Content |
|---------|---------|
| Current State | Where work stands |
| Critical Context | What next session needs to know |
| Files Modified | Key files touched |
| Pending Items | What remains to be done |
| Learnings | L-docs captured during session |

### Naming Convention

```
session_YYYY-MM-DD_<topic>.md
session_YYYY-MM-DD_HHMM.md  (if multiple sessions per day)
HANDOFF_<topic>_YYYY-MM-DD.md
```

## Anti-Patterns

| Anti-Pattern | Why Bad | Instead |
|--------------|---------|---------|
| No session notes | Context lost between sessions | Always create session note |
| Missing HANDOFF | Continuity broken | Create HANDOFF for ongoing work |
| Too verbose | Hard to scan | Focus on decisions and actions |

## Cross-References

| Document | Relationship |
|----------|--------------|
| `.aget/patterns/session/wake_up.py` | Session initialization |
| `.aget/patterns/session/wind_down.py` | Session finalization |
| `planning/` | PROJECT_PLANs referenced in sessions |

---

*Template version: 1.0.0 (G-1.9 discoverability)*
*Created by: private-aget-framework-AGET*
"""


def get_charter_md(name: str, archetype: str) -> str:
    """Generate governance/CHARTER.md content."""
    return f"""# Agent Charter: {name}

**Version**: 1.0.0
**Created**: {datetime.now().strftime("%Y-%m-%d")}
**Archetype**: {archetype}

---

## What This Agent IS

- **{archetype.title()} Role**: [Describe primary function]
- **Domain Expert**: [Describe domain expertise]

## What This Agent IS NOT

- **Autonomous Actor**: Does not take external actions without approval
- **Cross-boundary Operator**: Stays within defined scope

## Authority

### Autonomous
- L-doc creation
- Documentation
- Session management

### Requires Approval
- Strategic decisions
- External communications

### Escalate
- Breaking changes
- Major commitments

---

*Charter established {datetime.now().strftime("%Y-%m-%d")} per v3.0 migration*
"""


def get_mission_md(name: str, north_star: str) -> str:
    """Generate governance/MISSION.md content."""
    return f"""# Mission: {name}

**Version**: 1.0.0
**Updated**: {datetime.now().strftime("%Y-%m-%d")}

---

## North Star

> {north_star or "Define the agent's guiding purpose"}

## Purpose

[Describe the agent's core purpose]

## Goals

### G1: Primary Goal
[Describe primary goal]

### G2: Secondary Goal
[Describe secondary goal]

## Success Metrics

| Metric | Target | Measurement |
|--------|--------|-------------|
| [Metric 1] | [Target] | [How measured] |

---

*Mission established {datetime.now().strftime("%Y-%m-%d")} per v3.0 migration*
"""


def get_manifest_yaml(
    name: str,
    archetype: str,
    specialization: str,
    north_star: str,
    portfolio: str,
    managed_by: str
) -> str:
    """Generate manifest.yaml content."""
    return f"""apiVersion: aget.framework/v1
kind: InstanceManifest
manifest_version: "3.0"

metadata:
  name: {name}
  version: 1.0.0
  agent_type: {archetype.title()}
  archetype: {archetype}
  specialization: {specialization}
  created: "{datetime.now().strftime('%Y-%m-%d')}"
  updated: "{datetime.now().strftime('%Y-%m-%d')}"
  author: Principal
  status: active
  portfolio: {portfolio}

composition:
  base_template: template-{archetype}-aget
  capabilities:
    - name: session-protocols
      version: ">=1.0.0"
    - name: evolution-tracking
      version: ">=1.0.0"
    - name: governance-balanced
      version: ">=1.0.0"

instance:
  north_star: "{north_star or 'Define agent purpose'}"
  managed_by: {managed_by}

validation:
  dag_validated: true
  conflicts_checked: true
  last_validated: "{datetime.now().strftime('%Y-%m-%d')}"
"""


def get_scope_boundaries_md(name: str, portfolio: str) -> str:
    """Generate governance/SCOPE_BOUNDARIES.md content."""
    return f"""# Scope Boundaries: {name}

**Version**: 1.0.0
**Updated**: {datetime.now().strftime("%Y-%m-%d")}
**Portfolio**: {portfolio or "main"}

---

## In Scope

### Primary Domain
- [Define primary domain]

### Operational
- Session management
- L-doc creation
- Knowledge management

## Out of Scope

### Explicitly Excluded
- External actions without approval
- Cross-portfolio operations

### Escalation Required
- Major changes
- External communications

## Boundaries

### Data Classification
- Standard handling unless specified otherwise

### Temporal
- Session scope defined at wake-up
- Project scope defined in PROJECT_PLAN

---

*Scope boundaries established {datetime.now().strftime("%Y-%m-%d")} per v3.0 migration*
"""


# =============================================================================
# Migration Functions
# =============================================================================

def handle_legacy_files(agent_path: Path, dry_run: bool) -> dict:
    """
    Detect and remove legacy version-bearing files (CAP-MIG-014, L376).

    Archives files before removal for safety.

    Returns dict with removed files and any errors.
    """
    results = {
        "detected": [],
        "archived": [],
        "removed": [],
        "errors": [],
    }

    for legacy_rel_path in LEGACY_FILES:
        legacy_path = agent_path / legacy_rel_path

        if legacy_path.exists():
            results["detected"].append(legacy_rel_path)
            print(f"  DETECT: {legacy_rel_path} (legacy file)")

            if not dry_run:
                try:
                    # Archive first (safety)
                    archive_dir = agent_path / ".aget" / "archive" / "legacy_v3_migration"
                    archive_dir.mkdir(parents=True, exist_ok=True)
                    archive_path = archive_dir / legacy_path.name

                    shutil.copy2(legacy_path, archive_path)
                    results["archived"].append(str(archive_path))
                    print(f"  ARCHIVE: {legacy_rel_path} -> .aget/archive/legacy_v3_migration/")

                    # Remove original
                    legacy_path.unlink()
                    results["removed"].append(legacy_rel_path)
                    print(f"  REMOVE: {legacy_rel_path} (superseded by manifest.yaml)")

                    # Clean up empty parent directory
                    parent_dir = legacy_path.parent
                    if parent_dir.exists() and not any(parent_dir.iterdir()):
                        parent_dir.rmdir()
                        print(f"  REMOVE: {parent_dir.relative_to(agent_path)}/ (empty directory)")

                except Exception as e:
                    results["errors"].append(f"Failed to handle {legacy_rel_path}: {e}")
                    print(f"  ERROR: Failed to handle {legacy_rel_path}: {e}")

    return results


def count_ldocs(agent_path: Path) -> int:
    """Count L-docs in evolution directory."""
    evolution_dir = agent_path / ".aget" / "evolution"
    if not evolution_dir.exists():
        return 0
    return len(list(evolution_dir.glob("L*.md")))


def get_current_version_info(agent_path: Path) -> dict:
    """Read current version.json."""
    version_file = agent_path / ".aget" / "version.json"
    if version_file.exists():
        with open(version_file) as f:
            return json.load(f)
    return {}


def find_project_plans(agent_path: Path) -> list:
    """Find PROJECT_PLANs in .aget/specs/."""
    specs_dir = agent_path / ".aget" / "specs"
    if not specs_dir.exists():
        return []
    return list(specs_dir.glob("PROJECT_PLAN_*.md"))


def migrate_instance(
    agent_path: Path,
    archetype: str,
    specialization: str,
    north_star: str,
    dry_run: bool = True
) -> dict:
    """
    Perform v3.0 migration on an instance.

    Returns dict with migration results.
    """
    results = {
        "agent_path": str(agent_path),
        "dry_run": dry_run,
        "created_dirs": [],
        "created_files": [],
        "moved_files": [],
        "updated_files": [],
        "legacy_removed": [],
        "errors": [],
    }

    # Get current state
    current_version = get_current_version_info(agent_path)
    agent_name = current_version.get("agent_name", agent_path.name)
    portfolio = current_version.get("portfolio", "main")
    managed_by = current_version.get("managed_by", "private-supervisor-AGET")
    ldoc_count = count_ldocs(agent_path)
    project_plans = find_project_plans(agent_path)

    print(f"\n{'='*60}")
    print(f"AGET Instance Migration to v3.0")
    print(f"{'='*60}")
    print(f"Agent: {agent_name}")
    print(f"Path: {agent_path}")
    print(f"Archetype: {archetype}")
    print(f"Specialization: {specialization}")
    print(f"L-docs: {ldoc_count}")
    print(f"PROJECT_PLANs to move: {len(project_plans)}")
    print(f"Mode: {'DRY RUN' if dry_run else 'EXECUTE'}")
    print(f"{'='*60}\n")

    # =========================================================================
    # GATE 1: Structure
    # =========================================================================
    print("=== GATE 1: Structure ===\n")

    # Create 5D directories
    for dim in FIVE_D_DIRS:
        dim_path = agent_path / ".aget" / dim
        if not dim_path.exists():
            print(f"  CREATE: .aget/{dim}/")
            results["created_dirs"].append(f".aget/{dim}")
            if not dry_run:
                dim_path.mkdir(parents=True, exist_ok=True)

    # Create core visible directories
    for dir_name in CORE_VISIBLE_DIRS:
        dir_path = agent_path / dir_name
        if not dir_path.exists():
            print(f"  CREATE: {dir_name}/")
            results["created_dirs"].append(dir_name)
            if not dry_run:
                dir_path.mkdir(parents=True, exist_ok=True)

    # Create archetype-specific directories
    if archetype in ARCHETYPE_DIRS:
        for dir_name in ARCHETYPE_DIRS[archetype]:
            dir_path = agent_path / dir_name
            if not dir_path.exists():
                print(f"  CREATE: {dir_name}/ (archetype-specific)")
                results["created_dirs"].append(dir_name)
                if not dry_run:
                    dir_path.mkdir(parents=True, exist_ok=True)

    # Create knowledge/README.md if not exists (L403 fix)
    knowledge_readme_path = agent_path / "knowledge" / "README.md"
    if not knowledge_readme_path.exists():
        print(f"  CREATE: knowledge/README.md (L403 population guidance)")
        results["created_files"].append("knowledge/README.md")
        if not dry_run:
            with open(knowledge_readme_path, 'w') as f:
                f.write(get_knowledge_readme())
    else:
        print(f"  SKIP: knowledge/README.md (already exists)")

    # Create governance/README.md if not exists (G-1.9 discoverability)
    governance_readme_path = agent_path / "governance" / "README.md"
    if not governance_readme_path.exists():
        print(f"  CREATE: governance/README.md (G-1.9 discoverability)")
        results["created_files"].append("governance/README.md")
        if not dry_run:
            with open(governance_readme_path, 'w') as f:
                f.write(get_governance_readme())
    else:
        print(f"  SKIP: governance/README.md (already exists)")

    # Create planning/README.md if not exists (G-1.9 discoverability)
    planning_readme_path = agent_path / "planning" / "README.md"
    if not planning_readme_path.exists():
        print(f"  CREATE: planning/README.md (G-1.9 discoverability)")
        results["created_files"].append("planning/README.md")
        if not dry_run:
            with open(planning_readme_path, 'w') as f:
                f.write(get_planning_readme())
    else:
        print(f"  SKIP: planning/README.md (already exists)")

    # Create sessions/README.md if not exists (G-1.9 discoverability)
    sessions_readme_path = agent_path / "sessions" / "README.md"
    if not sessions_readme_path.exists():
        print(f"  CREATE: sessions/README.md (G-1.9 discoverability)")
        results["created_files"].append("sessions/README.md")
        if not dry_run:
            with open(sessions_readme_path, 'w') as f:
                f.write(get_sessions_readme())
    else:
        print(f"  SKIP: sessions/README.md (already exists)")

    # Move PROJECT_PLANs
    if project_plans:
        planning_dir = agent_path / "planning"
        for pp in project_plans:
            dest = planning_dir / pp.name
            print(f"  MOVE: .aget/specs/{pp.name} -> planning/{pp.name}")
            results["moved_files"].append(f"{pp.name}")
            if not dry_run:
                shutil.move(str(pp), str(dest))

    print("\nGATE 1: COMPLETE\n")

    # =========================================================================
    # GATE 2: Identity + Persona
    # =========================================================================
    print("=== GATE 2: Identity + Persona ===\n")

    # identity.json
    identity_path = agent_path / ".aget" / "identity.json"
    print(f"  CREATE: .aget/identity.json")
    results["created_files"].append(".aget/identity.json")
    if not dry_run:
        identity = get_identity_template(agent_name, north_star)
        with open(identity_path, 'w') as f:
            json.dump(identity, f, indent=2)

    # persona/archetype.yaml
    archetype_path = agent_path / ".aget" / "persona" / "archetype.yaml"
    print(f"  CREATE: .aget/persona/archetype.yaml")
    results["created_files"].append(".aget/persona/archetype.yaml")
    if not dry_run:
        with open(archetype_path, 'w') as f:
            f.write(get_archetype_yaml(archetype, specialization))

    # persona/style.yaml
    style_path = agent_path / ".aget" / "persona" / "style.yaml"
    print(f"  CREATE: .aget/persona/style.yaml")
    results["created_files"].append(".aget/persona/style.yaml")
    if not dry_run:
        with open(style_path, 'w') as f:
            f.write(get_style_yaml())

    print("\nGATE 2: COMPLETE\n")

    # =========================================================================
    # GATE 3: Remaining 5D Config
    # =========================================================================
    print("=== GATE 3: Remaining 5D Config ===\n")

    configs = [
        (".aget/memory/layer_config.yaml", get_layer_config_yaml(ldoc_count)),
        (".aget/memory/inheritance.yaml", get_inheritance_yaml(managed_by)),
        (".aget/reasoning/decision_authority.yaml", get_decision_authority_yaml()),
        (".aget/reasoning/planning_patterns.yaml", get_planning_patterns_yaml()),
        (".aget/skills/capabilities.yaml", get_capabilities_yaml(archetype)),
        (".aget/context/relationships.yaml", get_relationships_yaml(managed_by, portfolio)),
        (".aget/context/scope.yaml", get_scope_yaml()),
    ]

    for config_path, content in configs:
        full_path = agent_path / config_path
        print(f"  CREATE: {config_path}")
        results["created_files"].append(config_path)
        if not dry_run:
            with open(full_path, 'w') as f:
                f.write(content)

    print("\nGATE 3: COMPLETE\n")

    # =========================================================================
    # GATE 4: Governance
    # =========================================================================
    print("=== GATE 4: Governance ===\n")

    gov_files = [
        ("governance/CHARTER.md", get_charter_md(agent_name, archetype)),
        ("governance/MISSION.md", get_mission_md(agent_name, north_star)),
        ("governance/SCOPE_BOUNDARIES.md", get_scope_boundaries_md(agent_name, portfolio)),
    ]

    for gov_path, content in gov_files:
        full_path = agent_path / gov_path
        if not full_path.exists():
            print(f"  CREATE: {gov_path}")
            results["created_files"].append(gov_path)
            if not dry_run:
                with open(full_path, 'w') as f:
                    f.write(content)
        else:
            print(f"  SKIP: {gov_path} (already exists)")

    print("\nGATE 4: COMPLETE\n")

    # =========================================================================
    # GATE 4.5: Manifest
    # =========================================================================
    print("=== GATE 4.5: Manifest ===\n")

    manifest_path = agent_path / "manifest.yaml"
    if not manifest_path.exists():
        print(f"  CREATE: manifest.yaml")
        results["created_files"].append("manifest.yaml")
        if not dry_run:
            with open(manifest_path, 'w') as f:
                f.write(get_manifest_yaml(
                    agent_name, archetype, specialization,
                    north_star, portfolio, managed_by
                ))
    else:
        print(f"  SKIP: manifest.yaml (already exists)")

    print("\nGATE 4.5: COMPLETE\n")

    # =========================================================================
    # GATE 5: Finalize
    # =========================================================================
    print("=== GATE 5: Finalize ===\n")

    # Update version.json
    version_path = agent_path / ".aget" / "version.json"
    print(f"  UPDATE: .aget/version.json")
    results["updated_files"].append(".aget/version.json")

    if not dry_run:
        new_version = current_version.copy()
        new_version.update({
            "aget_version": "3.0.0-beta.3",
            "manifest_version": "3.0",
            "updated": datetime.now().strftime("%Y-%m-%d"),
            "instance_type": "aget",
            "archetype": archetype,
            "specialization": specialization,
        })

        # Add migration history
        migration_entry = {
            "from_version": current_version.get("aget_version", "2.x"),
            "to_version": "3.0.0-beta.3",
            "date": datetime.now().strftime("%Y-%m-%d"),
            "method": "migrate_instance_to_v3.py",
            "changes": [
                f"Created 5D directories",
                f"Created governance/, planning/, sessions/, knowledge/ visible directories",
                f"Created directory READMEs (L403 + G-1.9 discoverability)",
                f"Moved {len(project_plans)} PROJECT_PLANs to planning/",
                f"Created identity.json",
                f"Created 5D YAML configurations",
                f"Created governance files",
                f"Removed legacy files (CAP-MIG-014)"
            ]
        }

        if "migration_history" not in new_version:
            new_version["migration_history"] = []
        if isinstance(new_version["migration_history"], list):
            new_version["migration_history"].append(migration_entry)

        with open(version_path, 'w') as f:
            json.dump(new_version, f, indent=2)

    # Update AGENTS.md @aget-version tag
    agents_md_path = agent_path / "AGENTS.md"
    claude_md_path = agent_path / "CLAUDE.md"

    # Check which file exists (AGENTS.md preferred, CLAUDE.md as fallback)
    target_md = None
    if agents_md_path.exists():
        target_md = agents_md_path
    elif claude_md_path.exists() and not claude_md_path.is_symlink():
        target_md = claude_md_path

    if target_md:
        print(f"  UPDATE: {target_md.name} (@aget-version tag)")
        results["updated_files"].append(str(target_md.name))

        if not dry_run:
            content = target_md.read_text()
            # Replace @aget-version: X.Y.Z with new version
            updated_content = re.sub(
                r'@aget-version:\s*[\d.]+(-[a-zA-Z0-9.]+)?',
                '@aget-version: 3.0.0-beta.3',
                content
            )
            target_md.write_text(updated_content)

    print("\nGATE 5: COMPLETE\n")

    # =========================================================================
    # GATE 5.5: Legacy File Cleanup (CAP-MIG-014, L376)
    # =========================================================================
    print("=== GATE 5.5: Legacy File Cleanup (CAP-MIG-014) ===\n")

    legacy_results = handle_legacy_files(agent_path, dry_run)

    if legacy_results["detected"]:
        results["legacy_removed"] = legacy_results["removed"]
        if legacy_results["errors"]:
            results["errors"].extend(legacy_results["errors"])
    else:
        print("  No legacy files detected")

    print("\nGATE 5.5: COMPLETE\n")

    # =========================================================================
    # Summary
    # =========================================================================
    print(f"{'='*60}")
    print("MIGRATION SUMMARY")
    print(f"{'='*60}")
    print(f"Directories created: {len(results['created_dirs'])}")
    print(f"Files created: {len(results['created_files'])}")
    print(f"Files moved: {len(results['moved_files'])}")
    print(f"Files updated: {len(results['updated_files'])}")
    print(f"Legacy files removed: {len(results['legacy_removed'])}")

    if dry_run:
        print(f"\n{'='*60}")
        print("DRY RUN - No changes made")
        print("Run with --execute to apply changes")
        print(f"{'='*60}")
    else:
        print(f"\n{'='*60}")
        print("MIGRATION COMPLETE")
        print(f"{'='*60}")
        print("\nNext steps:")
        print("  1. Review .aget/identity.json north_star")
        print("  2. Review governance/ content")
        print("  3. Customize 5D YAML files as needed")
        print("")
        print("  4. Validate structure (CAP-MIG-015):")
        print(f"     python3 ~/github/aget-framework/aget/validation/validate_template_instance.py {agent_path}")
        print("")
        print("  5. Run contract tests (CAP-MIG-015):")
        print(f"     cd {agent_path} && python3 -m pytest tests/test_identity_contract.py -v")
        print("")
        print("  6. Test session protocol:")
        print(f"     python3 {agent_path}/.aget/patterns/session/wake_up.py")
        print("")
        print("  7. Commit changes")

    return results


# =============================================================================
# Main
# =============================================================================

def main():
    parser = argparse.ArgumentParser(
        description="Migrate AGET instance to v3.0 5D Composition Architecture",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    # Dry run (see what would be done)
    python3 migrate_instance_to_v3.py /path/to/agent --archetype advisor

    # Execute migration
    python3 migrate_instance_to_v3.py /path/to/agent --archetype advisor --execute

    # With all options
    python3 migrate_instance_to_v3.py /path/to/agent \\
        --archetype advisor \\
        --specialization impact-advisor \\
        --north-star "Maximize Principal's world impact" \\
        --execute

Reference:
    L395: Instance v3.0 Migration Pattern
    L400: Conceptual vs Structural Migration Understanding
        """
    )

    parser.add_argument("agent_path", type=Path, help="Path to agent directory")
    parser.add_argument("--archetype", choices=ARCHETYPES, required=True,
                        help="Agent archetype")
    parser.add_argument("--specialization", default=None,
                        help="Agent specialization within archetype")
    parser.add_argument("--north-star", default=None,
                        help="North star statement (purpose)")
    parser.add_argument("--dry-run", action="store_true", default=True,
                        help="Show what would be done (default)")
    parser.add_argument("--execute", action="store_true",
                        help="Actually perform the migration")

    args = parser.parse_args()

    # Validate agent path
    if not args.agent_path.exists():
        print(f"ERROR: Agent path does not exist: {args.agent_path}")
        sys.exit(1)

    if not (args.agent_path / ".aget" / "version.json").exists():
        print(f"ERROR: Not a valid AGET agent (no .aget/version.json)")
        sys.exit(1)

    # Determine mode
    dry_run = not args.execute

    # Run migration
    results = migrate_instance(
        agent_path=args.agent_path,
        archetype=args.archetype,
        specialization=args.specialization or args.archetype,
        north_star=args.north_star,
        dry_run=dry_run
    )

    # Exit with error if any errors occurred
    if results["errors"]:
        sys.exit(1)


if __name__ == "__main__":
    main()
